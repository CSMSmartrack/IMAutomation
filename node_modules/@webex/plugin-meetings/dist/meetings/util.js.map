{"version":3,"sources":["util.js"],"names":["MeetingsUtil","extractDestination","destination","type","dest","_LOCUS_ID_","url","ParameterError","temp","split","length","UUID_REG","test","id","getMeetingAddedType","_INCOMING_","_CREATED_","handleRoapMercury","envelope","meetingCollection","data","eventType","LOCUSEVENT","MESSAGE_ROAP","meeting","getByKey","CORRELATION_ID","correlationId","roap","roapEvent","checkForCorrelationId","deviceUrl","locus","devices","self","foundDevice","find","device"],"mappings":";;;;;;AAAA;;AAIA;;AAQA;;;;;;AAEA,IAAMA,eAAe,EAArB;;AAEAA,aAAaC,kBAAb,GAAkC,UAACC,WAAD,EAAcC,IAAd,EAAuB;AACvD,MAAIC,OAAOF,WAAX;;AAEA,MAAIC,SAASE,qBAAb,EAAyB;AACvB,QAAI,EAAEH,eAAeA,YAAYI,GAA7B,CAAJ,EAAuC;AACrC,YAAM,IAAIC,mBAAJ,CAAmB,kEAAnB,CAAN;AACD;AACD,QAAMC,OAAON,YAAYI,GAAZ,CAAgBG,KAAhB,CAAsB,GAAtB,CAAb;;AAEAL,WAAOI,KAAKA,KAAKE,MAAL,GAAc,CAAnB,CAAP;AACD;;AAED;AACA,MAAIC,oBAASC,IAAT,CAAcR,IAAd,CAAJ,EAAyB;AACvB,WAAOA,IAAP;AACD;;AAED;AACA;AACA;AACA,SAAO,gCAAmBA,IAAnB,EAAyBS,EAAzB,IAA+BT,IAAtC;AACD,CArBD;;AAuBAJ,aAAac,mBAAb,GAAmC,UAACX,IAAD;AAAA,SAAWA,SAASE,qBAAT,GAAsBU,qBAAtB,GAAmCC,oBAA9C;AAAA,CAAnC;;AAEAhB,aAAaiB,iBAAb,GAAiC,UAACC,QAAD,EAAWC,iBAAX,EAAiC;AAAA,MACzDC,IADyD,GACjDF,QADiD,CACzDE,IADyD;AAAA,MAEzDC,SAFyD,GAE5CD,IAF4C,CAEzDC,SAFyD;;;AAIhE,MAAIA,cAAcC,sBAAWC,YAA7B,EAA2C;AACzC,QAAMC,UAAUL,kBAAkBM,QAAlB,CAA2BC,yBAA3B,EAA2CN,KAAKO,aAAhD,CAAhB;;AAEA,QAAIH,OAAJ,EAAa;AACXA,cAAQI,IAAR,CAAaC,SAAb,CAAuBT,IAAvB;AACD;AACF;AACF,CAXD;;AAaApB,aAAa8B,qBAAb,GAAqC,UAACC,SAAD,EAAYC,KAAZ,EAAsB;AACzD,MAAIC,UAAU,EAAd;;AAEA,MAAID,KAAJ,EAAW;AACT,QAAIA,SAASA,MAAME,IAAf,IAAuBF,MAAME,IAAN,CAAWD,OAAtC,EAA+C;AAC7CA,gBAAUD,MAAME,IAAN,CAAWD,OAArB;AACD;;AAED,QAAME,cAAcF,QAAQG,IAAR,CAAa,UAACC,MAAD;AAAA,aAAYA,OAAO/B,GAAP,KAAeyB,SAA3B;AAAA,KAAb,CAApB;;AAEA,QAAII,eAAeA,YAAYR,aAA/B,EAA8C;AAC5C,aAAOQ,YAAYR,aAAnB;AACD;AACF;;AAED,SAAO,KAAP;AACD,CAhBD;;kBAkBe3B,Y","file":"util.js","sourcesContent":["import {\n  deconstructHydraId\n} from '@webex/common';\n\nimport {\n  _LOCUS_ID_,\n  _INCOMING_,\n  _CREATED_,\n  LOCUSEVENT,\n  CORRELATION_ID,\n  UUID_REG\n} from '../constants';\nimport ParameterError from '../common/errors/parameter';\n\nconst MeetingsUtil = {};\n\nMeetingsUtil.extractDestination = (destination, type) => {\n  let dest = destination;\n\n  if (type === _LOCUS_ID_) {\n    if (!(destination && destination.url)) {\n      throw new ParameterError('You cannot create a meeting by locus without a locus.url defined');\n    }\n    const temp = destination.url.split('/');\n\n    dest = temp[temp.length - 1];\n  }\n\n  // If the destination is a UUID, assume it is an internal conversation ID.\n  if (UUID_REG.test(dest)) {\n    return dest;\n  }\n\n  // Next, assume it is a valid Hydra room ID.\n  // If decoding fails, it is a SIP or other destination.\n  // if the id is not present we will use the default destination\n  return deconstructHydraId(dest).id || dest;\n};\n\nMeetingsUtil.getMeetingAddedType = (type) => (type === _LOCUS_ID_ ? _INCOMING_ : _CREATED_);\n\nMeetingsUtil.handleRoapMercury = (envelope, meetingCollection) => {\n  const {data} = envelope;\n  const {eventType} = data;\n\n  if (eventType === LOCUSEVENT.MESSAGE_ROAP) {\n    const meeting = meetingCollection.getByKey(CORRELATION_ID, data.correlationId);\n\n    if (meeting) {\n      meeting.roap.roapEvent(data);\n    }\n  }\n};\n\nMeetingsUtil.checkForCorrelationId = (deviceUrl, locus) => {\n  let devices = [];\n\n  if (locus) {\n    if (locus && locus.self && locus.self.devices) {\n      devices = locus.self.devices;\n    }\n\n    const foundDevice = devices.find((device) => device.url === deviceUrl);\n\n    if (foundDevice && foundDevice.correlationId) {\n      return foundDevice.correlationId;\n    }\n  }\n\n  return false;\n};\n\nexport default MeetingsUtil;\n"]}