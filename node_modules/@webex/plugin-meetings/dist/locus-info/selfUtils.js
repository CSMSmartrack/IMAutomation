'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _constants = require('../constants');

var _parameter = require('../common/errors/parameter');

var _parameter2 = _interopRequireDefault(_parameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var selfUtils = {};

/**
 * parses the relevant values for self: muted, guest, moderator, mediaStatus, state, joinedWith, creator, id
 * @param {Object} self
 * @param {String} deviceId
 * @returns {undefined}
 */
selfUtils.parse = function (self, deviceId) {
  if (self) {
    return {
      muted: selfUtils.getMuted(self),
      lastModified: selfUtils.getLastModified(self),
      modifiedBy: selfUtils.getModifiedBy(self),
      guest: self.guest,
      moderator: self.moderator,
      mediaStatus: selfUtils.getStatus(self.status),
      state: self.state,
      // TODO: give a proper name . With same device as login or different login`
      // Some times we might have joined with both mobile and web
      joinedWith: self.devices.find(function (device) {
        return deviceId === device.url;
      }),
      creator: self.isCreator, // check if its used,
      selfId: self.id,
      selfIdentity: selfUtils.getSelfIdentity(self),
      selfUrl: self.url
    };
  }

  return null;
};

selfUtils.getSelves = function (oldSelf, newSelf, deviceId) {
  var previous = oldSelf && selfUtils.parse(oldSelf, deviceId);
  var current = newSelf && selfUtils.parse(newSelf, deviceId);
  var updates = {};

  updates.isUnadmittedGuest = selfUtils.isUnadmittedGuest(current);
  updates.isAdmittedGuest = selfUtils.isAdmittedGuest(previous, current);
  updates.isMutedByOthers = selfUtils.mutedByOthers(previous, current);
  updates.moderatorChanged = selfUtils.moderatorChanged(previous, current);

  return {
    previous: previous,
    current: current,
    updates: {
      isUnadmittedGuest: selfUtils.isUnadmittedGuest(current),
      isAdmittedGuest: selfUtils.isAdmittedGuest(previous, current),
      mutedByOthers: selfUtils.mutedByOthers(previous, current)
    }
  };
};

selfUtils.getLastModified = function (self) {
  if (!self || !self.controls || !self.controls.audio || !self.controls.audio.meta || !self.controls.audio.meta.lastModified) {
    return null;
  }

  return self.controls.audio.meta.lastModified;
};

selfUtils.getModifiedBy = function (self) {
  if (!self || !self.controls || !self.controls.audio || !self.controls.audio.meta || !self.controls.audio.meta.modifiedBy) {
    return null;
  }

  return self.controls.audio.meta.modifiedBy;
};

/**
 * get the id from the self object
 * @param {Object} self
 * @returns {String}
 */
selfUtils.getSelfIdentity = function (self) {
  if (!self && !self.person) {
    return null;
  }

  return self.person.id;
};

/**
 * get the muted property from the self object
 * @param {Object} self
 * @returns {Boolean}
 */
selfUtils.getMuted = function (self) {
  if (!self || !self.controls || !self.controls.audio) {
    return null;
  }

  return self.controls.audio.muted;
};

selfUtils.getStatus = function (status) {
  return {
    audio: status.audioStatus,
    video: status.videoStatus,
    slides: status.videoSlidesStatus
  };
};

/**
 * @param {Object} check
 * @returns {Boolean}
 */
selfUtils.isLocusGuestUnadmitted = function (check) {
  return check && check.guest && check.state === _constants._IDLE_;
};

/**
 * @param {Object} check
 * @returns {Boolean}
 */
selfUtils.isLocusGuestAdmitted = function (check) {
  return check && check.guest && check.state === _constants._JOINED_;
};

/**
 * @param {Object} self
 * @returns {Boolean}
 * @throws {Error} when self is undefined
 */
selfUtils.isUnadmittedGuest = function (self) {
  if (!self) {
    throw new _parameter2.default('self must be defined to determine if self is unadmitted as guest.');
  }

  return selfUtils.isLocusGuestUnadmitted(self);
};

selfUtils.moderatorChanged = function (oldSelf, changedSelf) {
  if (!oldSelf) {
    return true;
  }
  if (!changedSelf) {
    throw new _parameter2.default('New self must be defined to determine if self transitioned moderator status.');
  }

  return oldSelf.moderator !== changedSelf.moderator;
};

/**
 * @param {Object} oldSelf
 * @param {Object} changedSelf
 * @returns {Boolean}
 * @throws {Error} if changed self was undefined
 */
selfUtils.isAdmittedGuest = function (oldSelf, changedSelf) {
  if (!oldSelf) {
    // if there was no previous locus, it couldn't have been admitted yet
    return false;
  }
  if (!changedSelf) {
    throw new _parameter2.default('New self must be defined to determine if self transitioned to admitted as guest.');
  }

  return selfUtils.isLocusGuestUnadmitted(oldSelf) && selfUtils.isLocusGuestAdmitted(changedSelf);
};

selfUtils.mutedByOthers = function (oldSelf, changedSelf) {
  if (!changedSelf) {
    throw new _parameter2.default('New self must be defined to determine if self was muted by others.');
  }

  return changedSelf.muted && (oldSelf.lastModified !== changedSelf.lastModified || oldSelf.modifiedBy !== changedSelf.modifiedBy);
};

/**
 * extract the sipUrl from the partner
 * @param {Object} partner
 * @param {Object} info
 * @returns {Object}
 */

selfUtils.getSipUrl = function (partner, type, sipUri) {
  // For webex meeting the sipUrl gets updated in info parser
  if (partner && type === _constants._CALL_) {
    return { sipUri: partner.person.sipUrl || partner.person.emailAddress || partner.person.email };
  }

  return { sipUri: sipUri };
};

exports.default = selfUtils;
//# sourceMappingURL=selfUtils.js.map
